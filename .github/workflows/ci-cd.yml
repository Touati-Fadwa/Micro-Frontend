name: Full Stack CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  # Configuration des ports
  GRAFANA_PORT: 30300
  PROMETHEUS_PORT: 30090
  APP_PORT: 30080
  
  # Namespaces
  APP_NAMESPACE: bibliotheque
  MONITORING_NAMESPACE: monitoring
  
  # Images Docker
  FRONTEND_IMAGE: touatifadwa/bibliotheque-frontend
  PROMETHEUS_IMAGE: prom/prometheus:v2.40.0
  GRAFANA_IMAGE: grafana/grafana:9.3.0

jobs:
  build-and-test:
    runs-on: self-hosted
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Nécessaire pour SonarQube

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build project
      run: CI='' npm run build

    - name: Run tests
      run: npm test -- --coverage

    - name: SonarQube Analysis
      uses: SonarSource/sonarqube-scan-action@v5.0.0
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: build/

  build-and-push:
    needs: build-and-test
    runs-on: self-hosted
    if: github.event_name != 'pull_request'
    
    steps:
    - uses: actions/checkout@v3
    - uses: actions/download-artifact@v4
      with:
        name: frontend-build

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        push: true
        tags: |
          ${{ env.FRONTEND_IMAGE }}:${{ github.sha }}
          ${{ env.FRONTEND_IMAGE }}:latest
        cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE }}:latest
        cache-to: type=inline

  deploy:
    needs: build-and-push
    runs-on: self-hosted
    if: github.event_name != 'pull_request'
    
    steps:
    - uses: actions/checkout@v3

    - name: Configure Kubernetes Access
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.K3S_CONFIG }}" | base64 -d > ~/.kube/config
        
        # Remplacer localhost par l'IP publique
        SERVER_IP=$(curl -s ifconfig.me)
        sed -i "s/127.0.0.1/${SERVER_IP}/g" ~/.kube/config
        
        # Sécuriser les permissions
        chmod 600 ~/.kube/config
        
        # Tester la connexion
        kubectl cluster-info
        kubectl get nodes

    - name: Deploy Application
      run: |
        # Créer le namespace s'il n'existe pas
        kubectl create namespace ${{ env.APP_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Déployer l'application
        kubectl apply -f k8s/deployment.yaml -n ${{ env.APP_NAMESPACE }}
        
        # Attendre que le déploiement soit prêt
        kubectl wait --for=condition=available \
          --timeout=300s \
          deployment/bibliotheque-frontend \
          -n ${{ env.APP_NAMESPACE }}
        
        # Afficher les informations de déploiement
        echo "=== Application Déployée ==="
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
        NODE_PORT=$(kubectl get svc bibliotheque-frontend-service -n ${{ env.APP_NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
        echo "Accès: http://${NODE_IP}:${NODE_PORT}"

  monitoring:
    needs: deploy
    runs-on: self-hosted
    timeout-minutes: 20
    
    steps:
    - name: Configure Kubernetes Access
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.K3S_CONFIG }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Setup Monitoring Namespace
      run: |
        kubectl apply -f - <<EOF
        apiVersion: v1
        kind: Namespace
        metadata:
          name: ${{ env.MONITORING_NAMESPACE }}
        EOF

    - name: Deploy Prometheus Stack
      run: |
        # Prometheus ConfigMap
        kubectl apply -f - <<EOF
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: prometheus-config
          namespace: ${{ env.MONITORING_NAMESPACE }}
        data:
          prometheus.yml: |
            global:
              scrape_interval: 15s
              evaluation_interval: 15s
            
            scrape_configs:
              - job_name: 'kubernetes-apiservers'
                kubernetes_sd_configs:
                - role: endpoints
                scheme: https
                tls_config:
                  ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
                relabel_configs:
                - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]
                  action: keep
                  regex: default;kubernetes;https
        EOF

        # Prometheus Deployment
        kubectl apply -f - <<EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: prometheus
          namespace: ${{ env.MONITORING_NAMESPACE }}
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: prometheus
          template:
            metadata:
              labels:
                app: prometheus
            spec:
              containers:
              - name: prometheus
                image: ${{ env.PROMETHEUS_IMAGE }}
                args:
                - "--config.file=/etc/prometheus/prometheus.yml"
                ports:
                - containerPort: 9090
                volumeMounts:
                - name: config
                  mountPath: /etc/prometheus
              volumes:
              - name: config
                configMap:
                  name: prometheus-config
        EOF

        # Prometheus Service
        kubectl apply -f - <<EOF
        apiVersion: v1
        kind: Service
        metadata:
          name: prometheus
          namespace: ${{ env.MONITORING_NAMESPACE }}
        spec:
          type: NodePort
          ports:
          - port: 9090
            targetPort: 9090
            nodePort: ${{ env.PROMETHEUS_PORT }}
          selector:
            app: prometheus
        EOF

    - name: Deploy Grafana
      run: |
        # Grafana ConfigMap
        kubectl apply -f - <<EOF
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: grafana-datasources
          namespace: ${{ env.MONITORING_NAMESPACE }}
        data:
          prometheus.yaml: |
            apiVersion: 1
            datasources:
            - name: Prometheus
              type: prometheus
              url: http://prometheus:9090
              access: proxy
              isDefault: true
        EOF

        # Grafana Deployment
        kubectl apply -f - <<EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: grafana
          namespace: ${{ env.MONITORING_NAMESPACE }}
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: grafana
          template:
            metadata:
              labels:
                app: grafana
            spec:
              containers:
              - name: grafana
                image: ${{ env.GRAFANA_IMAGE }}
                ports:
                - containerPort: 3000
                volumeMounts:
                - name: datasources
                  mountPath: /etc/grafana/provisioning/datasources
              volumes:
              - name: datasources
                configMap:
                  name: grafana-datasources
        EOF

        # Grafana Service
        kubectl apply -f - <<EOF
        apiVersion: v1
        kind: Service
        metadata:
          name: grafana
          namespace: ${{ env.MONITORING_NAMESPACE }}
        spec:
          type: NodePort
          ports:
          - port: 3000
            targetPort: 3000
            nodePort: ${{ env.GRAFANA_PORT }}
          selector:
            app: grafana
        EOF

    - name: Verify Monitoring Stack
      run: |
        # Vérifier Prometheus
        kubectl rollout status deployment/prometheus -n ${{ env.MONITORING_NAMESPACE }} --timeout=180s
        
        # Vérifier Grafana
        kubectl rollout status deployment/grafana -n ${{ env.MONITORING_NAMESPACE }} --timeout=180s
        
        # Afficher les URLs d'accès
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[0].address}')
        echo "=== Monitoring Stack ==="
        echo "Grafana:    http://${NODE_IP}:${{ env.GRAFANA_PORT }} (admin/admin)"
        echo "Prometheus: http://${NODE_IP}:${{ env.PROMETHEUS_PORT }}"

  k9s-guide:
    needs: monitoring
    runs-on: ubuntu-latest
    steps:
    - name: Generate Access Guide
      run: |
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[0].address}')
        cat <<EOF
        ==== Guide d'Accès ====
        Application Frontend: http://${NODE_IP}:${{ env.APP_PORT }}
        Grafana Dashboard:    http://${NODE_IP}:${{ env.GRAFANA_PORT }} (admin/admin)
        Prometheus:           http://${NODE_IP}:${{ env.PROMETHEUS_PORT }}
        
        ==== Commandes Utiles ====
        # Accéder au dashboard K9s
        k9s -n ${{ env.APP_NAMESPACE }}
        
        # Voir les logs
        kubectl logs -f <pod-name> -n ${{ env.APP_NAMESPACE }}
        
        # Redémarrer le déploiement
        kubectl rollout restart deployment/bibliotheque-frontend -n ${{ env.APP_NAMESPACE }}
        EOF